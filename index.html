<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AES-GCM æ™ºèƒ½ç°½ååŠ å¯†å·¥å…· (V5)</title>
    <style>
        :root {
            --bg-color: #121212;
            --card-bg: #1e1e1e;
            --text-color: #e0e0e0;
            --accent-enc: #ff5252;
            --accent-dec: #69f0ae;
        }
        body {
            font-family: 'Segoe UI', Consolas, sans-serif;
            background: var(--bg-color); color: var(--text-color);
            display: flex; flex-direction: column; align-items: center;
            min-height: 100vh; margin: 0; padding: 20px;
        }
        h1 { font-weight: 300; letter-spacing: 2px; color: #fff; margin-bottom: 5px; }
        .badge { background: #333; padding: 2px 8px; border-radius: 4px; font-size: 0.8rem; color: #03a9f4; }
        
        .container { display: flex; gap: 20px; width: 100%; max-width: 900px; margin-top: 20px; flex-wrap: wrap; }
        
        .drop-zone {
            flex: 1; min-width: 300px; background: var(--card-bg);
            padding: 40px 20px; border-radius: 12px; border: 2px dashed #444;
            text-align: center; cursor: pointer; transition: 0.2s;
        }
        .drop-zone:hover { transform: translateY(-3px); }
        .enc-zone:hover { border-color: var(--accent-enc); box-shadow: 0 5px 15px rgba(255, 82, 82, 0.2); }
        .dec-zone:hover { border-color: var(--accent-dec); box-shadow: 0 5px 15px rgba(105, 240, 174, 0.2); }

        .icon { font-size: 3rem; margin-bottom: 10px; }
        h2 { margin: 10px 0; font-size: 1.2rem; }
        p { color: #888; font-size: 0.9rem; }

        .input-group { width: 100%; max-width: 900px; margin-bottom: 10px; }
        input[type="password"] {
            width: 100%; padding: 15px; background: #2c2c2c; border: 1px solid #444;
            color: #fff; border-radius: 8px; text-align: center; font-size: 1.1rem;
            box-sizing: border-box; transition: 0.3s;
        }
        input[type="password"]:focus { border-color: #03a9f4; outline: none; }

        #log-area {
            width: 100%; max-width: 900px; margin-top: 20px;
            background: #000; padding: 15px; border-radius: 8px;
            font-family: monospace; font-size: 0.9rem; color: #bbb;
            min-height: 100px; max-height: 200px; overflow-y: auto; border: 1px solid #333;
        }
        .err { color: var(--accent-enc); }
        .ok { color: var(--accent-dec); }
        .info { color: #03a9f4; }

        #progress-bar { width: 100%; max-width: 900px; height: 4px; background: #333; margin-top: 20px; display: none; }
        #progress-fill { height: 100%; width: 0%; background: #03a9f4; transition: width 0.1s; }

        input[type="file"] { display: none; }
    </style>
</head>
<body>

    <h1>FILE VAULT <span class="badge">V5 SIGNATURE</span></h1>
    <p style="color:#666; margin-bottom: 20px;">æ”¯æ´ç„¡é™å¤§æª”æ¡ˆ â€¢ æ™ºèƒ½è­˜åˆ¥åŠ å¯†æª” â€¢ éš±å½¢æ¨¡å¼</p>

    <div class="input-group">
        <input type="password" id="password" placeholder="è«‹è¼¸å…¥å¯†ç¢¼ (PASSWORD)" autocomplete="off">
    </div>

    <div class="container">
        <div class="drop-zone enc-zone" id="drop-enc">
            <div class="icon">ğŸ”’</div>
            <h2>åŠ å¯† (Encrypt)</h2>
            <p>å³ä½¿æª”åä¸è®Šï¼Œæˆ‘å€‘ä¹ŸæœƒåŠ ä¸Šéš±å½¢ç°½å</p>
            <input type="file" id="file-enc">
        </div>

        <div class="drop-zone dec-zone" id="drop-dec">
            <div class="icon">ğŸ”“</div>
            <h2>è§£å¯† (Decrypt)</h2>
            <p>è‡ªå‹•æª¢æ¸¬æ˜¯å¦ç‚ºåŠ å¯†æª”æ¡ˆ</p>
            <input type="file" id="file-dec">
        </div>
    </div>

    <div id="progress-bar"><div id="progress-fill"></div></div>
    <div id="log-area"><div class="info">> ç³»çµ±å°±ç·’ã€‚è«‹ä½¿ç”¨ Chrome/Edge é›»è…¦ç‰ˆã€‚</div></div>

<script>
    // --- æ ¸å¿ƒé…ç½® ---
    const CHUNK_SIZE = 1024 * 1024 * 16; // 16MB åˆ†å¡Š
    const PBKDF2_ITERATIONS = 100000;
    const MAGIC_SIG = new TextEncoder().encode("GEM_LOCK"); // 8 bytes ç°½å
    const SALT_LEN = 16;
    const IV_LEN = 12;

    // --- UI Helpers ---
    const ui = {
        log: (msg, type) => {
            const el = document.getElementById('log-area');
            el.innerHTML = `<div class="${type}">[${new Date().toLocaleTimeString()}] ${msg}</div>` + el.innerHTML;
        },
        progress: (pct) => {
            const bar = document.getElementById('progress-bar');
            bar.style.display = pct >= 0 ? 'block' : 'none';
            document.getElementById('progress-fill').style.width = pct + '%';
        }
    };

    if (!window.showSaveFilePicker) alert("âš ï¸ éŒ¯èª¤ï¼šè«‹ä½¿ç”¨ Chrome æˆ– Edge ç€è¦½å™¨ä»¥æ”¯æ´å¤§æª”æ¡ˆå¯«å…¥ã€‚");

    // --- åŠ å¯†æ ¸å¿ƒ ---
    async function deriveKey(password, salt) {
        const enc = new TextEncoder();
        const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(password), {name: "PBKDF2"}, false, ["deriveKey"]);
        return crypto.subtle.deriveKey(
            { name: "PBKDF2", salt: salt, iterations: PBKDF2_ITERATIONS, hash: "SHA-256" },
            keyMaterial, { name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]
        );
    }

    // --- åŠ å¯†æµç¨‹ ---
    async function encryptFile(file) {
        const password = document.getElementById('password').value;
        if (!password) return ui.log("âŒ éŒ¯èª¤ï¼šå¯†ç¢¼ä¸èƒ½ç‚ºç©º", "err");

        try {
            // æª¢æŸ¥æ˜¯å¦å·²ç¶“è¢«åŠ å¯†é (é˜²æ­¢é‡è¤‡åŠ å¯†)
            const head = new Uint8Array(await file.slice(0, 8).arrayBuffer());
            if (head.every((val, i) => val === MAGIC_SIG[i])) {
                if(!confirm("âš ï¸ è­¦å‘Šï¼šæ­¤æª”æ¡ˆä¼¼ä¹å·²ç¶“åŠ å¯†éäº†ï¼\nå†æ¬¡åŠ å¯†æœƒå°è‡´ã€Œé›™é‡åŠ å¯†ã€ï¼Œè§£å¯†æœƒéå¸¸éº»ç…©ã€‚\nç¢ºå®šè¦ç¹¼çºŒå—ï¼Ÿ")) return;
            }

            const newHandle = await window.showSaveFilePicker({ suggestedName: file.name });
            const writable = await newHandle.createWritable();

            ui.log(`ğŸ”’ é–‹å§‹åŠ å¯†: ${file.name}`, "info");
            ui.progress(0);

            // 1. å¯«å…¥ MAGIC SIGNATURE (8 bytes)
            await writable.write(MAGIC_SIG);

            // 2. ç”Ÿæˆä¸¦å¯«å…¥ Salt (16 bytes)
            const salt = crypto.getRandomValues(new Uint8Array(SALT_LEN));
            await writable.write(salt);

            const key = await deriveKey(password, salt);
            const stream = file.stream();
            const reader = stream.getReader();
            
            // 3. ç·©è¡è®€å–è¿´åœˆ
            let buffer = new Uint8Array(0);
            let processed = 0;

            while (true) {
                const { done, value } = await reader.read();
                if (value) {
                    const temp = new Uint8Array(buffer.length + value.length);
                    temp.set(buffer);
                    temp.set(value, buffer.length);
                    buffer = temp;
                }

                while (buffer.length >= CHUNK_SIZE || (done && buffer.length > 0)) {
                    const sliceLen = Math.min(buffer.length, CHUNK_SIZE);
                    const chunk = buffer.slice(0, sliceLen);
                    buffer = buffer.slice(sliceLen);

                    const iv = crypto.getRandomValues(new Uint8Array(IV_LEN));
                    const encryptedChunk = await crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, key, chunk);
                    
                    // æ ¼å¼: [IV 12] + [Len 4] + [Data]
                    await writable.write(iv);
                    await writable.write(new Uint32Array([encryptedChunk.byteLength]));
                    await writable.write(encryptedChunk);

                    processed += sliceLen;
                    ui.progress((processed / file.size) * 100);
                    if (buffer.length === 0 && done) break;
                }
                if (done) break;
            }
            await writable.close();
            ui.log("âœ… åŠ å¯†æˆåŠŸï¼æª”æ¡ˆå·²ç°½åã€‚", "ok");
            ui.progress(-1);

        } catch (e) {
            console.error(e);
            ui.log(`âŒ åŠ å¯†å¤±æ•—: ${e.message}`, "err");
            ui.progress(-1);
        }
    }

    // --- è§£å¯†æµç¨‹ ---
    async function decryptFile(file) {
        const password = document.getElementById('password').value;
        if (!password) return ui.log("âŒ éŒ¯èª¤ï¼šå¯†ç¢¼ä¸èƒ½ç‚ºç©º", "err");

        try {
            ui.log(`ğŸ” åˆ†ææª”æ¡ˆ: ${file.name}`, "info");
            
            // 1. é©—è­‰ MAGIC SIGNATURE
            // å¦‚æœé€™ä¸€æ­¥å¤±æ•—ï¼Œä»£è¡¨ç”¨æˆ¶é¸éŒ¯æª”æ¡ˆï¼Œæˆ–é¸åˆ°äº†æœªåŠ å¯†çš„åŸæª”
            const sigBlob = file.slice(0, 8);
            const sigData = new Uint8Array(await sigBlob.arrayBuffer());
            
            // æ¯”å°ç°½å
            const isEncrypted = sigData.every((val, i) => val === MAGIC_SIG[i]);
            if (!isEncrypted) {
                throw new Error("æ­¤æª”æ¡ˆã€Œä¸æ˜¯ã€æœ¬å·¥å…·åŠ å¯†çš„æª”æ¡ˆï¼(æ‰¾ä¸åˆ° GEM_LOCK ç°½å)");
            }

            const newHandle = await window.showSaveFilePicker({ suggestedName: "decrypted_" + file.name });
            const writable = await newHandle.createWritable();
            ui.log(`ğŸ”“ ç°½åé©—è­‰é€šéï¼Œé–‹å§‹è§£å¯†...`, "info");
            ui.progress(0);

            // 2. è®€å– Salt (Offset 8 ~ 24)
            let offset = 8;
            const saltBlob = file.slice(offset, offset + SALT_LEN);
            const salt = new Uint8Array(await saltBlob.arrayBuffer());
            offset += SALT_LEN;

            const key = await deriveKey(password, salt);
            const totalSize = file.size;

            // 3. è§£å¯†è¿´åœˆ
            while (offset < totalSize) {
                // è®€ IV
                if (offset + IV_LEN > totalSize) break;
                const ivBlob = file.slice(offset, offset + IV_LEN);
                const iv = new Uint8Array(await ivBlob.arrayBuffer());
                offset += IV_LEN;

                // è®€é•·åº¦
                const lenBlob = file.slice(offset, offset + 4);
                const lenArr = new Uint32Array(await lenBlob.arrayBuffer());
                const chunkLen = lenArr[0];
                offset += 4;

                // å®‰å…¨æ€§æª¢æŸ¥
                if (chunkLen > CHUNK_SIZE + 1024 || chunkLen <= 0) {
                     throw new Error("æª”æ¡ˆçµæ§‹æå£ (å€å¡Šé•·åº¦ç•°å¸¸)");
                }

                // è®€æ•¸æ“š
                const dataBlob = file.slice(offset, offset + chunkLen);
                const data = await dataBlob.arrayBuffer();
                offset += chunkLen;

                try {
                    const decryptedChunk = await crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, key, data);
                    await writable.write(decryptedChunk);
                } catch (e) {
                    throw new Error("å¯†ç¢¼éŒ¯èª¤ (AES-GCM é©—è­‰å¤±æ•—)");
                }

                ui.progress((offset / totalSize) * 100);
            }

            await writable.close();
            ui.log("âœ… è§£å¯†æˆåŠŸï¼", "ok");
            ui.progress(-1);

        } catch (e) {
            console.error(e);
            ui.log(`âŒ è§£å¯†å¤±æ•—: ${e.message}`, "err");
            ui.progress(-1);
        }
    }

    // --- äº‹ä»¶ ---
    const setup = (id, fn) => {
        const el = document.getElementById(id);
        const inp = el.querySelector('input');
        el.onclick = () => inp.click();
        inp.onchange = (e) => { if(e.target.files[0]) fn(e.target.files[0]); inp.value=''; };
        el.ondragover = (e) => { e.preventDefault(); };
        el.ondrop = (e) => { e.preventDefault(); if(e.dataTransfer.files[0]) fn(e.dataTransfer.files[0]); };
    };
    setup('drop-enc', encryptFile);
    setup('drop-dec', decryptFile);

</script>
</body>
</html>
